Вам дано описание наследования классов в формате JSON.

Описание представляет из себя массив JSON-объектов, которые соответствуют классам. У каждого JSON-объекта есть поле **name**, которое содержит имя класса, и поле **parents**, которое содержит список имен прямых предков.

**Пример**:

`[{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]`

﻿Эквивалент на Python:

```
class A:
    pass

class B(A, C):
    pass

class C(A):
    pass
```

Гарантируется, что никакой класс не наследуется от себя явно или косвенно, и что никакой класс не наследуется явно от одного класса более одного раза.

Для каждого класса вычислите предком скольких классов он является и выведите эту информацию в следующем формате.

**<имя класса> : <количество потомков>**

Выводить классы следует в лексикографическом порядке.

**Sample Input**:

`[{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]`

**Sample Output**:

```
A : 3
B : 1
C : 2
```

# Solution / Решение

```
import json

initial = json.loads(input())

with_children = {element['name']: [] for element in initial}

for eli in initial:
    for elc in with_children:
        if elc in eli['parents']:
            with_children[elc].append(eli['name'])

for element in with_children:
    with_children[element] = set(with_children[element])

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for next in graph[start] - visited:
        dfs(graph, next, visited)
    return visited

for element in sorted(with_children.keys()):
    print(element, ':', len(dfs(with_children, element)))
```